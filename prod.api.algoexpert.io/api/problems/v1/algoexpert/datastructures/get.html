{"datastructures":[{"name":"Introduction","section":"","acl":{"isFree":true,"productRequired":["algoexpert"],"isAvailable":true},"releaseDate":"","available":true,"video":{"instructor":"Clément Mihailescu","vimeoId":"376961593","duration":5,"thumbnail":"https://i.vimeocdn.com/video/836229237.jpg?mw=400\u0026mh=225\u0026q=70"},"description":"Coding
interviews. Problem-solving skills. Algorithm questions. What do you call the intersection of their Venn Diagram?\n\nHint: it starts with \"data\" and ends with \"structures\".\n","hasCodeExample":false,"numPreReqs":0,"preReqs":[],"numKeyTerms":0,"keyTerms":[]},{"name":"What
Are Data Structures?","section":"","acl":{"isFree":false,"productRequired":["algoexpert"],"isAvailable":false},"releaseDate":"","available":false,"video":{"instructor":"Clément Mihailescu","vimeoId":null,"duration":9,"thumbnail":"https://i.vimeocdn.com/video/839360391.jpg?mw=400\u0026mh=225\u0026q=70"},"description":"The
elementary particles of algorithms, data structures are woven into the very fabric of computer science and are essential building blocks of many a solution to coding interview problems.\n\nSans the need for a microscope.\n","hasCodeExample":false,"numPreReqs":0,"preReqs":[],"numKeyTerms":0,"keyTerms":[]},{"name":"Complexity
Analysis","section":"","acl":{"isFree":false,"productRequired":["algoexpert"],"isAvailable":false},"releaseDate":"","available":false,"video":{"instructor":"Clément Mihailescu","vimeoId":null,"duration":8,"thumbnail":"https://i.vimeocdn.com/video/836926206.jpg?mw=400\u0026mh=225\u0026q=70"},"description":"Two
dimensions, time and space, diverged in a yellow wood, and I—\nI watched the Complexity Analysis video on AlgoExpert,\nAnd that has made all the difference (in my coding interviews).\n","hasCodeExample":false,"numPreReqs":0,"preReqs":[],"numKeyTerms":3,"keyTerms":[]},{"name":"Memory","section":"","acl":{"isFree":false,"productRequired":["algoexpert"],"isAvailable":false},"releaseDate":"","available":false,"video":{"instructor":"Clément
Mihailescu","vimeoId":null,"duration":28,"thumbnail":"https://i.vimeocdn.com/video/838159878.jpg?mw=400\u0026mh=225\u0026q=70"},"description":"The bedrock of all data structures, memory is the underlying concept that you absolutely need to know in order
to understand why data structures work the way they do.\n\nBits and bytes may keep me up all night,\nBut memory will never ail me!\n","hasCodeExample":false,"numPreReqs":0,"preReqs":[],"numKeyTerms":4,"keyTerms":[]},{"name":"Big O Notation","section":"","acl":{"isFree":false,"productRequired":["algoexpert"],"isAvailable":false},"releaseDate":"","available":false,"video":{"instructor":"Clément
Mihailescu","vimeoId":null,"duration":37,"thumbnail":"https://i.vimeocdn.com/video/839257782.jpg?mw=400\u0026mh=225\u0026q=70"},"description":"The speed and memory usage of an algorithm aren't necessarily fixed; they might change depending on the input.
So how do we express the performance of an algorithm then?\n\nEnter Big O Notation, a powerful tool that allows us to generalize the space-time complexity of an algorithm as a function of its input size.\n","hasCodeExample":false,"numPreReqs":2,"preReqs":[],"numKeyTerms":1,"keyTerms":[]},{"name":"Logarithm","section":"","acl":{"isFree":true,"productRequired":["algoexpert"],"isAvailable":true},"releaseDate":"","available":true,"video":{"instructor":"Clément
Mihailescu","vimeoId":"378706213","duration":20,"thumbnail":"https://i.vimeocdn.com/video/838544153.jpg?mw=400\u0026mh=225\u0026q=70"},"description":"That scary-looking word you know you should understand but just really...don’t? Yeah, that one. It’s
time to make it your best friend.\n\nWarning: a logarithmless way of life will seem inconceivable after watching this video.\n","hasCodeExample":false,"numPreReqs":0,"preReqs":[],"numKeyTerms":1,"keyTerms":[{"name":"Logarithm","section":null,"definition":"\u003cp\u003eA
mathematical concept that's widely used in Computer Science and that's defined by the following equation:\u003c/p\u003e\n\u003cp\u003e\u003cb\u003elog\u003csub\u003eb\u003c/sub\u003e(x) = y\u003c/b\u003e if and only if \u003cb\u003eb\u003csup\u003ey\u003c/sup\u003e
= x\u003c/b\u003e\u003c/p\u003e\n\u003cp\u003eIn the context of coding interviews, the logarithm is used to describe the complexity analysis of algorithms, and\n its usage always implies a logarithm of base \u003cb\u003e2\u003c/b\u003e. In other words,
the logarithm used in the context of coding\n interviews is defined by the following equation:\u003c/p\u003e\n\u003cp\u003e\u003cb\u003elog(n) = y\u003c/b\u003e if and only if \u003cb\u003e2\u003csup\u003ey\u003c/sup\u003e = n\u003c/b\u003e\u003c/p\u003e\n\u003cp\u003eIn
plain English, if an algorithm has a logarithmic time complexity (\u003cb\u003eO(log(n))\u003c/b\u003e, where n is the size of the\n input), then whenever the algorithm's input doubles in size (i.e., whenever \u003cb\u003en\u003c/b\u003e doubles), the
number of\n operations needed to\n complete the algorithm only increases by one unit. Conversely, an algorithm with a linear time complexity would\n see its number of operations double if its input size doubled.\u003c/p\u003e\n\u003cp\u003eAs an example,
a linear-time-complexity algorithm with an input of size 1,000 might take roughly 1,000 operations to\n complete, whereas a logarithmic-time-complexity algorithm with the same input would take roughly 10 operations to\n complete, since \u003cb\u003e2\u003csup\u003e10\u003c/sup\u003e
~= 1,000\u003c/b\u003e.\u003c/p\u003e","url":null,"kinds":[],"isTech":false}]},{"name":"Arrays","section":"","acl":{"isFree":false,"productRequired":["algoexpert"],"isAvailable":false},"releaseDate":"","available":false,"video":{"instructor":"Clément
Mihailescu","vimeoId":null,"duration":42,"thumbnail":"https://i.vimeocdn.com/video/839039942.jpg?mw=400\u0026mh=225\u0026q=70"},"description":"Perhaps the most classic and most commonly used of all data structures, the array is deceptively simple. Key
word: \"deceptively.\"\n\nDon’t be fooled! Where it might appear trivially straightforward at surface level, it actually boasts an array—pun intended—of nuances worthy of taking a second gander.\n","hasCodeExample":false,"numPreReqs":0,"preReqs":[],"numKeyTerms":1,"keyTerms":[]},{"name":"Linked
Lists","section":"","acl":{"isFree":false,"productRequired":["algoexpert"],"isAvailable":false},"releaseDate":"","available":false,"video":{"instructor":"Clément Mihailescu","vimeoId":null,"duration":31,"thumbnail":"https://i.vimeocdn.com/video/838855987.jpg?mw=400\u0026mh=225\u0026q=70"},"description":"The
data structure whose singular purpose in life is to be reversed. Even right here on AlgoExpert, in fact.\n\nThat’s right, head on over to the hard questions list after watching this video, and reverse that bad boy every which way to Sunday.","hasCodeExample":false,"numPreReqs":0,"preReqs":[],"numKeyTerms":3,"keyTerms":[]},{"name":"Hash
Tables","section":"","acl":{"isFree":false,"productRequired":["algoexpert"],"isAvailable":false},"releaseDate":"","available":false,"video":{"instructor":"Clément Mihailescu","vimeoId":null,"duration":25,"thumbnail":"https://i.vimeocdn.com/video/839141317.jpg?mw=400\u0026mh=225\u0026q=70"},"description":"Fun.
Fast. Flexible. This beloved data structure is a fan favorite among interviewers and interviewees alike, and for good reason: it lends itself extremely well to any problem requiring some sort of lookup operation, of which (spoiler alert) there are many.\n\nWatch
out for those collisions though!\n","hasCodeExample":false,"numPreReqs":0,"preReqs":[],"numKeyTerms":1,"keyTerms":[]},{"name":"Stacks And Queues","section":"","acl":{"isFree":false,"productRequired":["algoexpert"],"isAvailable":false},"releaseDate":"","available":false,"video":{"instructor":"Clément
Mihailescu","vimeoId":null,"duration":13,"thumbnail":"https://i.vimeocdn.com/video/838180795.jpg?mw=400\u0026mh=225\u0026q=70"},"description":"Push. Pop. FIFO. LIFO. That pretty much sums up stacks and queues.\n\nOk, there might be a bit more to them
than meets the eye. Watch our video to find out. Plus, it even features nifty stick figures!\n","hasCodeExample":false,"numPreReqs":0,"preReqs":[],"numKeyTerms":2,"keyTerms":[]},{"name":"Strings","section":"","acl":{"isFree":false,"productRequired":["algoexpert"],"isAvailable":false},"releaseDate":"","available":false,"video":{"instructor":"Clément
Mihailescu","vimeoId":null,"duration":10,"thumbnail":"https://i.vimeocdn.com/video/838770087.jpg?mw=400\u0026mh=225\u0026q=70"},"description":"Not a standalone data structure per se, strings are generally considered to be a data type that behaves like
a data structure.\n\nNonetheless, they do possess a few interesting characteristics that earn them a dedicated video here in our course. Let’s dive in!\n","hasCodeExample":false,"numPreReqs":0,"preReqs":[],"numKeyTerms":1,"keyTerms":[]},{"name":"Graphs","section":"","acl":{"isFree":false,"productRequired":["algoexpert"],"isAvailable":false},"releaseDate":"","available":false,"video":{"instructor":"Clément
Mihailescu","vimeoId":null,"duration":19,"thumbnail":"https://i.vimeocdn.com/video/842686917.jpg?mw=400\u0026mh=225\u0026q=70"},"description":"These collections of edges and vertices might look as banal as a child's scribble on a restaurant table, but
they're of fundamental importance in discrete mathematics. The eponymous field of \"graph theory\" is dedicated to their study, and their importance in mathematics carries over to computer science.","hasCodeExample":false,"numPreReqs":0,"preReqs":[],"numKeyTerms":7,"keyTerms":[]},{"name":"Trees","section":"","acl":{"isFree":false,"productRequired":["algoexpert"],"isAvailable":false},"releaseDate":"","available":false,"video":{"instructor":"Clément
Mihailescu","vimeoId":null,"duration":20,"thumbnail":"https://i.vimeocdn.com/video/842677439.jpg?mw=400\u0026mh=225\u0026q=70"},"description":"A special type of graph, trees excel at storing data hierarchically and are commonly used as a means of testing
your knowledge of recursion during coding interviews.\n\nInteresting fact: unlike their botanical counterparts, these digital perennials sport but a single, unique root.","hasCodeExample":false,"numPreReqs":0,"preReqs":[],"numKeyTerms":7,"keyTerms":[]}],"glossary":[{"name":"Acyclic
Graph","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Array","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Balanced Binary Tree","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Big
O Notation","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Binary Tree","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Bit","section":null,"definition":"\u003cp\u003eShort for \u003cb\u003ebinary
digit\u003c/b\u003e, a bit is a fundamental unit of information in Computer Science that represents a\n state with one of two values, typically \u003cb\u003e0\u003c/b\u003e and \u003cb\u003e1\u003c/b\u003e.\u003c/p\u003e\n\u003cp\u003eAny data stored
in a computer is, at the most basic level, represented in bits.\u003c/p\u003e","url":null,"kinds":[],"isTech":false},{"name":"Byte","section":null,"definition":"\u003cp\u003eA group of eight \u003cb\u003ebits\u003c/b\u003e. For example, \u003cb\u003e01101000\u003c/b\u003e
is a byte.\u003c/p\u003e\n\u003cp\u003e\n A single byte can represent up to \u003cb\u003e256\u003c/b\u003e data values (\u003cb\u003e2\u003csup\u003e8\u003c/sup\u003e\u003c/b\n \u003e).\n\u003c/p\u003e\n\u003cp\u003e\n Since a \u003cb\u003ebinary number\u003c/b\u003e
is a number expressed with only two symbols, like\n \u003cb\u003e0\u003c/b\u003e and \u003cb\u003e1\u003c/b\u003e, a byte can effectively represent all of the numbers\n between 0 and 255, inclusive, in binary format.\n\u003c/p\u003e\n\u003cp\u003e\n The
following bytes represent the numbers 1, 2, 3, and 4 in binary format.\n\u003c/p\u003e\n\u003cpre\u003e\n1: 00000001\n2: 00000010\n3: 00000011\n4: 00000100\n\u003c/pre\u003e","url":null,"kinds":[],"isTech":false},{"name":"Circular Linked List","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Complete
Binary Tree","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Complexity Analysis","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Connected Graph","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Cyclic
Graph","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Directed Graph","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Doubly Linked List","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Fixed-Width
Integer","section":null,"definition":"\u003cp\u003e\n An integer represented by a fixed amount of \u003cb\u003ebits\u003c/b\u003e. For example, a\n \u003cb\u003e32-bit integer\u003c/b\u003e is an integer represented by 32 bits (4 bytes), and a\n \u003cb\u003e64-bit
integer\u003c/b\u003e is an integer represented by 64 bits (8 bytes).\n\u003c/p\u003e\n\u003cp\u003e\n The following is the 32-bit representation of the number 1, with clearly\n separated bytes:\n\u003c/p\u003e\n\u003cpre\u003e\n00000000 00000000 00000000
00000001\n\u003c/pre\u003e\n\u003cp\u003e\n The following is the 64-bit representation of the number 10, with clearly\n separated bytes:\n\u003c/p\u003e\n\u003cpre\u003e\n00000000 00000000 00000000 00000000 00000000 00000000 00000000 00001010\n\u003c/pre\u003e\n\u003cp\u003e\n
Regardless of how large an integer is, its fixed-width-integer representation\n is, by definition, made up of a constant number of bits.\n\u003c/p\u003e\n\u003cp\u003e\n It follows that, regardless of how large an integer is, an operation performed\n
on its fixed-width-integer representation consists of a constant number of bit\n manipulations, since the integer is made up of a fixed number of bits.\n\u003c/p\u003e","url":null,"kinds":[],"isTech":false},{"name":"Full Binary Tree","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Graph","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Graph
Cycle","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Hash Table","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"K-ary Tree","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Logarithm","section":null,"definition":"\u003cp\u003eA
mathematical concept that's widely used in Computer Science and that's defined by the following equation:\u003c/p\u003e\n\u003cp\u003e\u003cb\u003elog\u003csub\u003eb\u003c/sub\u003e(x) = y\u003c/b\u003e if and only if \u003cb\u003eb\u003csup\u003ey\u003c/sup\u003e
= x\u003c/b\u003e\u003c/p\u003e\n\u003cp\u003eIn the context of coding interviews, the logarithm is used to describe the complexity analysis of algorithms, and\n its usage always implies a logarithm of base \u003cb\u003e2\u003c/b\u003e. In other words,
the logarithm used in the context of coding\n interviews is defined by the following equation:\u003c/p\u003e\n\u003cp\u003e\u003cb\u003elog(n) = y\u003c/b\u003e if and only if \u003cb\u003e2\u003csup\u003ey\u003c/sup\u003e = n\u003c/b\u003e\u003c/p\u003e\n\u003cp\u003eIn
plain English, if an algorithm has a logarithmic time complexity (\u003cb\u003eO(log(n))\u003c/b\u003e, where n is the size of the\n input), then whenever the algorithm's input doubles in size (i.e., whenever \u003cb\u003en\u003c/b\u003e doubles), the
number of\n operations needed to\n complete the algorithm only increases by one unit. Conversely, an algorithm with a linear time complexity would\n see its number of operations double if its input size doubled.\u003c/p\u003e\n\u003cp\u003eAs an example,
a linear-time-complexity algorithm with an input of size 1,000 might take roughly 1,000 operations to\n complete, whereas a logarithmic-time-complexity algorithm with the same input would take roughly 10 operations to\n complete, since \u003cb\u003e2\u003csup\u003e10\u003c/sup\u003e
~= 1,000\u003c/b\u003e.\u003c/p\u003e","url":null,"kinds":[],"isTech":false},{"name":"Memory","section":null,"definition":"\u003cp\u003e\n Broadly speaking, memory is the foundational layer of computing, where all\n data is stored.\n\u003c/p\u003e\n\u003cp\u003e\n
In the context of coding interviews, it's important to note the following\n points:\n\u003c/p\u003e\n\u003cul\u003e\n \u003cli\u003eData stored in memory is stored in bytes and, by extension, bits.\u003c/li\u003e\n \u003cli\u003e\n Bytes in memory can
\"point\" to other bytes in memory, so as to store\n references to other data.\n \u003c/li\u003e\n \u003cli\u003e\n The amount of memory that a machine has is bounded, making it valuable to\n limit how much memory an algorithm takes up.\n \u003c/li\u003e\n
\u003cli\u003e\n Accessing a byte or a fixed number of bytes (like 4 bytes or 8 bytes in the\n case of \u003cb\u003e32-bit\u003c/b\u003e and \u003cb\u003e64-bit integers\u003c/b\u003e) is an elementary\n operation, which can be loosely treated as a single
unit of operational\n work.\n \u003c/li\u003e\n\u003c/ul\u003e","url":null,"kinds":[],"isTech":false},{"name":"Perfect Binary Tree","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Queue","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Singly
Linked List","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Space Complexity","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Stack","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"String","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Time
Complexity","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Tree","section":null,"definition":"","url":null,"kinds":[],"isTech":false},{"name":"Undirected Graph","section":null,"definition":"","url":null,"kinds":[],"isTech":false}]}